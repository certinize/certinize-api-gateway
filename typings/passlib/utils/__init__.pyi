"""
This type stub file was generated by pyright.
"""

import itertools
import inspect
import logging
import math
import os
import sys
import random
import re
import stringprep
import time
import unicodedata
import timeit
import types
from passlib.utils.compat import JYTHON, PY3, PYPY, add_doc, byte_elem_value, get_method_function, imap, irange, join_byte_elems, join_byte_values, join_bytes, join_unicode, nextgetter, suppress_cause, u, unicode, unicode_or_bytes_types, unicode_or_str
from binascii import Error as _BinAsciiError, a2b_base64, b2a_base64, hexlify, unhexlify
from base64 import b64decode, b64encode
from codecs import lookup as _lookup_codec
from functools import update_wrapper
from warnings import warn
from passlib.utils.binary import AB64_CHARS, BASE64_CHARS, BCRYPT_CHARS, Base64Engine, HASH64_CHARS, LazyBase64Engine, ab64_decode, ab64_encode, b64s_decode, b64s_encode, bcrypt64, h64, h64big
from passlib.utils.decor import classproperty, deprecated_function, deprecated_method, hybrid_method, memoized_property
from passlib.exc import ExpectedStringError, ExpectedTypeError, MissingBackendError

"""passlib.utils -- helpers for writing password hashes"""
log = ...
if JYTHON:
    ...
else:
    ...
if stringprep:
    ...
__all__ = ['JYTHON', 'sys_bits', 'unix_crypt_schemes', 'rounds_cost_values', 'consteq', 'saslprep', "xor_bytes", "render_bytes", 'is_same_codec', 'is_ascii_safe', 'to_bytes', 'to_unicode', 'to_native_str', 'has_crypt', 'test_crypt', 'safe_crypt', 'tick', 'rng', 'getrandbytes', 'getrandstr', 'generate_password', 'is_crypt_handler', 'is_crypt_context', 'has_rounds_info', 'has_salt_info']
sys_bits = ...
unix_crypt_schemes = ...
rounds_cost_values = ...
_BEMPTY = ...
_UEMPTY = ...
_USPACE = ...
MAX_PASSWORD_SIZE = ...
class SequenceMixin:
    """
    helper which lets result object act like a fixed-length sequence.
    subclass just needs to provide :meth:`_as_tuple()`.
    """
    def __repr__(self): # -> str:
        ...
    
    def __getitem__(self, idx):
        ...
    
    def __iter__(self):
        ...
    
    def __len__(self): # -> int:
        ...
    
    def __eq__(self, other) -> bool:
        ...
    
    def __ne__(self, other) -> bool:
        ...
    


if PY3:
    _VAR_KEYWORD = ...
    _VAR_ANY_SET = ...
    def accepts_keyword(func, key): # -> bool:
        """test if function accepts specified keyword"""
        ...
    
else:
    def accepts_keyword(func, key): # -> bool:
        """test if function accepts specified keyword"""
        ...
    
def update_mixin_classes(target, add=..., remove=..., append=..., before=..., after=..., dryrun=...):
    """
    helper to update mixin classes installed in target class.

    :param target:
        target class whose bases will be modified.

    :param add:
        class / classes to install into target's base class list.

    :param remove:
        class / classes to remove from target's base class list.

    :param append:
        by default, prepends mixins to front of list.
        if True, appends to end of list instead.

    :param after:
        optionally make sure all mixins are inserted after
        this class / classes.

    :param before:
        optionally make sure all mixins are inserted before
        this class / classes.

    :param dryrun:
        optionally perform all calculations / raise errors,
        but don't actually modify the class.
    """
    ...

def batch(source, size):
    """
    split iterable into chunks of <size> elements.
    """
    ...

def consteq(left, right): # -> bool:
    """Check two strings/bytes for equality.

    This function uses an approach designed to prevent
    timing analysis, making it appropriate for cryptography.
    a and b must both be of the same type: either str (ASCII only),
    or any type that supports the buffer protocol (e.g. bytes).

    Note: If a and b are of different lengths, or if an error occurs,
    a timing attack could theoretically reveal information about the
    types and lengths of a and b--but not their values.
    """
    ...

str_consteq = ...
def splitcomma(source, sep=...): # -> list[Unknown]:
    """split comma-separated string into list of elements,
    stripping whitespace.
    """
    ...

def saslprep(source, param=...): # -> str:
    """Normalizes unicode strings using SASLPrep stringprep profile.

    The SASLPrep profile is defined in :rfc:`4013`.
    It provides a uniform scheme for normalizing unicode usernames
    and passwords before performing byte-value sensitive operations
    such as hashing. Among other things, it normalizes diacritic
    representations, removes non-printing characters, and forbids
    invalid characters such as ``\\n``. Properly internationalized
    applications should run user passwords through this function
    before hashing.

    :arg source:
        unicode string to normalize & validate

    :param param:
        Optional noun identifying source parameter in error messages
        (Defaults to the string ``"value"``). This is mainly useful to make the caller's error
        messages make more sense contextually.

    :raises ValueError:
        if any characters forbidden by the SASLPrep profile are encountered.

    :raises TypeError:
        if input is not :class:`!unicode`

    :returns:
        normalized unicode string

    .. note::

        This function is not available under Jython,
        as the Jython stdlib is missing the :mod:`!stringprep` module
        (`Jython issue 1758320 <http://bugs.jython.org/issue1758320>`_).

    .. versionadded:: 1.6
    """
    ...

if stringprep is None:
    def saslprep(source, param=...):
        """stub for saslprep()"""
        ...
    
def render_bytes(source, *args): # -> bytes:
    """Peform ``%`` formating using bytes in a uniform manner across Python 2/3.

    This function is motivated by the fact that
    :class:`bytes` instances do not support ``%`` or ``{}`` formatting under Python 3.
    This function is an attempt to provide a replacement:
    it converts everything to unicode (decoding bytes instances as ``latin-1``),
    performs the required formatting, then encodes the result to ``latin-1``.

    Calling ``render_bytes(source, *args)`` should function roughly the same as
    ``source % args`` under Python 2.

    .. todo::
        python >= 3.5 added back limited support for bytes %,
        can revisit when 3.3/3.4 is dropped.
    """
    ...

if PY3:
    def bytes_to_int(value): # -> int:
        ...
    
    def int_to_bytes(value, count):
        ...
    
else:
    def bytes_to_int(value): # -> int:
        ...
    
    def int_to_bytes(value, count): # -> bytes:
        ...
    
def xor_bytes(left, right): # -> bytes:
    """Perform bitwise-xor of two byte strings (must be same size)"""
    ...

def repeat_string(source, size):
    """
    repeat or truncate <source> string, so it has length <size>
    """
    ...

def utf8_repeat_string(source, size): # -> bytes:
    """
    variant of repeat_string() which truncates to nearest UTF8 boundary.
    """
    ...

_BNULL = ...
_UNULL = ...
def right_pad_string(source, size, pad=...):
    """right-pad or truncate <source> string, so it has length <size>"""
    ...

def utf8_truncate(source, index): # -> bytes:
    """
    helper to truncate UTF8 byte string to nearest character boundary ON OR AFTER <index>.
    returned prefix will always have length of at least <index>, and will stop on the
    first byte that's not a UTF8 continuation byte (128 - 191 inclusive).
    since utf8 should never take more than 4 bytes to encode known unicode values,
    we can stop after ``index+3`` is reached.

    :param bytes source:
    :param int index:
    :rtype: bytes
    """
    ...

_ASCII_TEST_BYTES = ...
_ASCII_TEST_UNICODE = ...
def is_ascii_codec(codec): # -> bool:
    """Test if codec is compatible with 7-bit ascii (e.g. latin-1, utf-8; but not utf-16)"""
    ...

def is_same_codec(left, right): # -> bool:
    """Check if two codec names are aliases for same codec"""
    ...

_B80 = ...
_U80 = ...
def is_ascii_safe(source): # -> bool:
    """Check if string (bytes or unicode) contains only 7-bit ascii"""
    ...

def to_bytes(source, encoding=..., param=..., source_encoding=...): # -> bytes:
    """Helper to normalize input to bytes.

    :arg source:
        Source bytes/unicode to process.

    :arg encoding:
        Target encoding (defaults to ``"utf-8"``).

    :param param:
        Optional name of variable/noun to reference when raising errors

    :param source_encoding:
        If this is specified, and the source is bytes,
        the source will be transcoded from *source_encoding* to *encoding*
        (via unicode).

    :raises TypeError: if source is not unicode or bytes.

    :returns:
        * unicode strings will be encoded using *encoding*, and returned.
        * if *source_encoding* is not specified, byte strings will be
          returned unchanged.
        * if *source_encoding* is specified, byte strings will be transcoded
          to *encoding*.
    """
    ...

def to_unicode(source, encoding=..., param=...): # -> str:
    """Helper to normalize input to unicode.

    :arg source:
        source bytes/unicode to process.

    :arg encoding:
        encoding to use when decoding bytes instances.

    :param param:
        optional name of variable/noun to reference when raising errors.

    :raises TypeError: if source is not unicode or bytes.

    :returns:
        * returns unicode strings unchanged.
        * returns bytes strings decoded using *encoding*
    """
    ...

if PY3:
    def to_native_str(source, encoding=..., param=...): # -> str:
        ...
    
else:
    def to_native_str(source, encoding=..., param=...): # -> bytes:
        ...
    
@deprecated_function(deprecated="1.6", removed="1.7")
def to_hash_str(source, encoding=...): # -> bytes:
    """deprecated, use to_native_str() instead"""
    ...

_true_set = ...
_false_set = ...
_none_set = ...
def as_bool(value, none=..., param=...): # -> bool | None:
    """
    helper to convert value to boolean.
    recognizes strings such as "true", "false"
    """
    ...

def is_safe_crypt_input(value): # -> bool:
    """
    UT helper --
    test if value is safe to pass to crypt.crypt();
    under PY3, can't pass non-UTF8 bytes to crypt.crypt.
    """
    ...

def test_crypt(secret, hash):
    """check if :func:`crypt.crypt` supports specific hash
    :arg secret: password to test
    :arg hash: known hash of password to use as reference
    :returns: True or False
    """
    ...

timer = timeit.default_timer
tick = timer
def parse_version(source): # -> tuple[int, ...] | None:
    """helper to parse version string"""
    ...

def genseed(value=...): # -> int:
    """generate prng seed value from system resources"""
    ...

if has_urandom:
    rng = ...
else:
    rng = ...
def getrandbytes(rng, count): # -> bytes:
    """return byte-string containing *count* number of randomly generated bytes, using specified rng"""
    ...

def getrandstr(rng, charset, count): # -> str | bytes:
    """return string containing *count* number of chars/bytes, whose elements are drawn from specified charset, using specified rng"""
    ...

_52charset = ...
@deprecated_function(deprecated="1.7", removed="2.0", replacement="passlib.pwd.genword() / passlib.pwd.genphrase()")
def generate_password(size=..., charset=...): # -> str | bytes:
    """generate random password using given length & charset

    :param size:
        size of password.

    :param charset:
        optional string specified set of characters to draw from.

        the default charset contains all normal alphanumeric characters,
        except for the characters ``1IiLl0OoS5``, which were omitted
        due to their visual similarity.

    :returns: :class:`!str` containing randomly generated password.

    .. note::

        Using the default character set, on a OS with :class:`!SystemRandom` support,
        this function should generate passwords with 5.7 bits of entropy per character.
    """
    ...

_handler_attrs = ...
def is_crypt_handler(obj): # -> bool:
    """check if object follows the :ref:`password-hash-api`"""
    ...

_context_attrs = ...
def is_crypt_context(obj): # -> bool:
    """check if object appears to be a :class:`~passlib.context.CryptContext` instance"""
    ...

def has_rounds_info(handler): # -> bool:
    """check if handler provides the optional :ref:`rounds information <rounds-attributes>` attributes"""
    ...

def has_salt_info(handler): # -> bool:
    """check if handler provides the optional :ref:`salt information <salt-attributes>` attributes"""
    ...

